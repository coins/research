# RSA Groups of Unknown Order

Groups of unknown order have interesting applications such as accumulators with constant-size inclusion proof aggregation. Usually, RSA accumulators require a trusted setup. The following is an idea that might be able to remove the need for a trusted setup.

## Idea
We start with the `k`-th *primorial*, which is simply the product of the first `k` primes:

```
k# = 2 * 3 * 5 * 7 * ... * p_k
```

We see that for any prime `p > p_k`

```
n = k# - p 
```
can not be divisible by `2,3,...,p_k`. If `n` is composite, all factors `f_i` of `n` must be in the range 

```
p_k < f_i < n / p_k
``` 

## Example 

```javascript
const {primesList} = await import('https://coins.github.io/primes-js/src/primes/primes-list.js');
P = primesList.splice(0, 500) // the first 500 primes
n = P.reduce( (a,e)=> a*BigInt(e), 1n ) - BigInt(primesList[0])
```
Factoring out the "small" factors yields:
```
n = 517 844363 Ã— 
107675 179404 670452 030360 990863 929166 289336 165681 831486 115600 569765 323727 526686 761844
478472 995616 210491 579390 911765 029330 295026 354632 750965 909239 356837 466939 765020 651218
893247 626646 332489 388858 392260 097867 093275 357819 527051 453831 868535 146980 439715 179587
910406 117677 915552 809318 037203 640624 257858 899431 240332 260412 232281 798404 648298 908751
198926 800893 084770 325666 664960 961306 251429 800707 657761 607540 889220 162450 419567 242531
073235 790818 175149 254104 932585 151567 396470 946802 008878 372153 122485 841087 282236 309762
543719 719133 755534 515426 840960 322378 663024 919755 378943 085514 001777 462566 066162 250941
894933 191072 593019 934888 257117 186559 264819 831420 614948 178946 987657 588250 124991 411800
579376 880840 681112 104678 630949 244512 513029 084752 079277 111320 636552 647805 238264 121718
919422 123499 387744 215791 569730 338112 520320 647779 604510 254715 666732 473240 072907 435608
417111 254552 658053 192229 568705 476804 762854 264950 782133 283269 521032 781776 306567 123211
118523 834185 507548 644433 749151 746178 484218 473087 834859 222418 620539 337724 953288 925589
586821 455203 673303 352182 152480 702427 129726 309059 132659 047087 637309 823642 017163 080715
745919 322065 116711 892069 495628 972048 686092 964510 810845 925218 896537 478442 470163 624584
035595 964914 775411 056231 252693 491979 114582 336880 617911 777567 570078 239608 989839 871086
410122 703333 534519 746346 913926 226148 672842 858574 643109 305445 382576 637841 311399 345138
512345 359544 247424 192980 247265 066223 950313 832042 742456 993622 226914 638274 024518 251556
284886 341122 351676 064260 447938 571679 532559 552356 113960 189977 828296 088279 646804 601143
```
Fermat's little theorem yields simple compositeness certificates with e.g `2^(n-1) != 1 (mod n)`. So we just created a composite number `m` with 1512 decimal digits of which we don't know the factorization:
```
m = 107675 179404 670452 030360 990863 929166 289336 165681 831486 115600 569765 323727 526686 761844
478472 995616 210491 579390 911765 029330 295026 354632 750965 909239 356837 466939 765020 651218
893247 626646 332489 388858 392260 097867 093275 357819 527051 453831 868535 146980 439715 179587
910406 117677 915552 809318 037203 640624 257858 899431 240332 260412 232281 798404 648298 908751
198926 800893 084770 325666 664960 961306 251429 800707 657761 607540 889220 162450 419567 242531
073235 790818 175149 254104 932585 151567 396470 946802 008878 372153 122485 841087 282236 309762
543719 719133 755534 515426 840960 322378 663024 919755 378943 085514 001777 462566 066162 250941
894933 191072 593019 934888 257117 186559 264819 831420 614948 178946 987657 588250 124991 411800
579376 880840 681112 104678 630949 244512 513029 084752 079277 111320 636552 647805 238264 121718
919422 123499 387744 215791 569730 338112 520320 647779 604510 254715 666732 473240 072907 435608
417111 254552 658053 192229 568705 476804 762854 264950 782133 283269 521032 781776 306567 123211
118523 834185 507548 644433 749151 746178 484218 473087 834859 222418 620539 337724 953288 925589
586821 455203 673303 352182 152480 702427 129726 309059 132659 047087 637309 823642 017163 080715
745919 322065 116711 892069 495628 972048 686092 964510 810845 925218 896537 478442 470163 624584
035595 964914 775411 056231 252693 491979 114582 336880 617911 777567 570078 239608 989839 871086
410122 703333 534519 746346 913926 226148 672842 858574 643109 305445 382576 637841 311399 345138
512345 359544 247424 192980 247265 066223 950313 832042 742456 993622 226914 638274 024518 251556
284886 341122 351676 064260 447938 571679 532559 552356 113960 189977 828296 088279 646804 601143
```


## Discussion 
The obvious problem here is that we can give no strong guarantees about the size of the factors of `n` other than that they're much larger than `517844363`. Still, it might be worth to explore the idea further. A first optimization is to choose `n` as a difference of consecutive primes like:
```
n = 2 * 3 * ... * p_i - p_(i+1) * p_(i+2) * p_(i+3) * ... * p_k
```
This allows us to increase `k` and exclude more factors without increasing the size of `n`.